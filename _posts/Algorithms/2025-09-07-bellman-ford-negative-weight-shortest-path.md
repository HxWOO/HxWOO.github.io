---
layout: post
title:  "벨만-포드(Bellman-Ford) 알고리즘: 음수 가중치와 최단 경로"
date:   2025-09-07 00:00:00 +0900
categories: Algorithms
tags: [bellman-ford, algorithm, shortest_path, graph, python, negative_weight]
---

# 🚲 벨만-포드(Bellman-Ford) 알고리즘: 음수 가중치가 있는 그래프의 최단 경로 탐색

---

## 📚 벨만-포드 알고리즘이란?

**벨만-포드(Bellman-Ford) 알고리즘**은 가중치가 있는 그래프에서 **하나의 시작 정점에서 다른 모든 정점까지의 최단 경로를 찾는 알고리즘**이다.

[다익스트라 알고리즘](https://hxwoo.github.io/computer_science/2025/08/11/dijkstra-algorithm-shortest-path.html)과 유사한 목표를 가지지만, 가장 큰 차이점은 **음수 가중치 간선**을 처리할 수 있다는 것이다. 더 나아가, 벨만-포드는 최단 경로를 무한히 감소시킬 수 있는 **'음수 사이클(Negative Cycle)'** 의 존재 여부까지 탐지할 수 있는 강력한 기능을 제공한다.

이 알고리즘은 **'완화(Relaxation)'** 라는 기법을 반복적으로 적용하는 원리에 기반을 두고 있다.

---

## 💡 주요 개념

*   **단일 출발점 최단 경로 (Single-Source Shortest Path):** 하나의 시작 정점(`source`)에서 그래프 내의 다른 모든 정점까지의 최단 경로를 찾는 문제다.
*   **완화 (Relaxation):** 정점 `u`를 통해 정점 `v`로 가는 더 짧은 경로가 발견되었을 때, `v`까지의 최단 거리 추정치를 갱신하는 과정이다. 즉, `dist[v]`와 `dist[u] + weight(u, v)`를 비교하여 더 작은 값으로 `dist[v]`를 업데이트한다.
*   **음수 사이클 (Negative Cycle):** 그래프 내에 존재하는 사이클(순환 경로) 중에서, 해당 사이클을 구성하는 간선들의 가중치 합이 음수인 경우를 말한다. 음수 사이클이 존재하면 해당 사이클을 계속 돌 때마다 경로 비용이 무한히 작아지므로 '최단 경로'가 정의되지 않는다.

---

## 🚀 벨만-포드 알고리즘 동작 방식 (단계별 설명)

벨만-포드 알고리즘은 모든 간선에 대한 완화(Relaxation)를 반복적으로 수행하여 최단 경로를 찾아낸다. 핵심 아이디어는 **"시작점에서 특정 정점까지의 최단 경로는 최대 `V-1`개(V는 정점의 수)의 간선으로 이루어져 있다"** 는 사실에 기반한다.

1.  **초기화 (Initialization):**
    *   최단 거리를 저장할 1차원 배열 `dist`를 준비하고, 모든 원소를 `무한대(∞)`로 초기화한다.
    *   시작 정점 `s`의 거리 `dist[s]`는 `0`으로 설정한다.

2.  **반복적인 간선 완화 (Iterative Edge Relaxation):**
    *   그래프의 전체 정점 개수(V)보다 하나 적은 `V-1`번 만큼 다음 과정을 반복한다.
    *   그래프에 존재하는 **모든 간선 `(u, v)`** 에 대해 완화 작업을 수행한다.
        *   만약 `dist[u] + weight(u, v)`가 `dist[v]`보다 작다면, 더 짧은 경로를 찾은 것이므로 `dist[v]`를 `dist[u] + weight(u, v)`로 갱신한다.
        ```
        if dist[u] + weight(u, v) < dist[v]:
            dist[v] = dist[u] + weight(u, v)
        ```

3.  **음수 사이클 탐지 (Negative Cycle Detection):**
    *   `V-1`번의 반복이 끝나면, 모든 정점까지의 최단 경로는 계산이 완료된 상태여야 한다.
    *   **한 번 더** 모든 간선에 대해 완화 작업을 시도한다.
    *   이때 또다시 `dist` 배열의 값이 갱신되는 경우가 발생한다면, 이는 `V-1`개의 간선보다 더 긴 경로가 최단 경로임을 의미하며, 이는 **음수 사이클이 존재**한다는 뜻이다.

**가장 중요한 점**은 `V-1`번의 반복을 통해 최단 경로를 확정하고, 마지막 V번째 반복을 통해 음수 사이클의 존재 여부를 확인한다는 것이다.

---

## ⚠️ 중요한 특징 및 시간 복잡도

*   **시간 복잡도:** `O(V * E)` (V는 정점의 수, E는 간선의 수). `V-1`번의 반복문 안에서 모든 간선 `E`를 확인하기 때문이다.
*   **음수 가중치 처리:** 다익스트라와 달리 음수 가중치를 가진 간선이 있어도 정상적으로 동작한다. 이것이 벨만-포드의 가장 큰 장점이다.
*   **음수 사이클 탐지:** 알고리즘 수행 후 음수 사이클의 존재 여부를 확실하게 알 수 있다.
*   **구현:** 다익스트라에 비해 상대적으로 간단하지만, 그래프의 모든 간선을 매번 확인해야 하므로 간선 수가 많은 경우 비효율적일 수 있다.

---

## 💻 파이썬 구현 예시

다음은 벨만-포드 알고리즘을 파이썬으로 구현한 예시다. 그래프는 `(출발, 도착, 가중치)` 형태의 간선 리스트로 주어진다고 가정했다.

```python
def bellman_ford(graph_edges, num_vertices, source):
    """
    벨만-포드 알고리즘을 사용하여 단일 시작점에서의 최단 거리를 계산한다.

    Args:
        graph_edges (list of tuples): (u, v, weight) 형태의 간선 리스트.
        num_vertices (int): 그래프의 총 정점 수.
        source (int): 시작 정점.

    Returns:
        tuple: (최단 거리 리스트, 음수 사이클 존재 여부(bool)).
    """
    # 최단 거리 테이블을 무한대로 초기화
    dist = [float('inf')] * num_vertices
    dist[source] = 0

    # V-1번 동안 모든 간선에 대해 완화 작업 반복
    for i in range(num_vertices - 1):
        for u, v, weight in graph_edges:
            if dist[u] != float('inf') and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight

    # 음수 사이클 확인
    # V번째 반복에서 또다시 완화가 발생하면 음수 사이클 존재
    for u, v, weight in graph_edges:
        if dist[u] != float('inf') and dist[u] + weight < dist[v]:
            return dist, True  # 음수 사이클 발견

    return dist, False

# --- 예시 그래프 정의 (간선 리스트) ---
# 정점 개수
V = 5
# 간선 정보: (출발, 도착, 가중치)
edges = [
    (0, 1, -1), (0, 2, 4),
    (1, 2, 3), (1, 3, 2), (1, 4, 2),
    (3, 2, 5), (3, 1, 1),
    (4, 3, -3)
]
# 시작 정점
start_node = 0

# --- 벨만-포드 알고리즘 실행 ---
shortest_paths, has_negative_cycle = bellman_ford(edges, V, start_node)

# --- 결과 출력 ---
if has_negative_cycle:
    print("그래프에 음수 사이클이 존재합니다.")
else:
    print(f"정점 {start_node}에서 각 정점까지의 최단 경로:")
    for i in range(V):
        print(f"정점 {i}까지의 거리: {shortest_paths[i]}")

# 출력 결과:
# 정점 0에서 각 정점까지의 최단 경로:
# 정점 0까지의 거리: 0
# 정점 1까지의 거리: -1
# 정점 2까지의 거리: 2
# 정점 3까지의 거리: -2
# 정점 4까지의 거리: 1
```
> 그래프는 간선 리스트 형태로 표현되며, 각 간선은 `(출발 정점, 도착 정점, 가중치)`의 튜플로 나타낸다. 만약 인접 행렬의 형태로 그래프가 주어진다면, 간선 리스트로 변환하는 과정이 필요하다.
---

## ✅ 마무리

**벨만-포드 알고리즘**은 음수 가중치가 포함된 그래프에서 최단 경로를 찾아야 할 때 반드시 필요한 알고리즘이다. 다익스트라 알고리즘보다 시간 복잡도는 높지만, **음수 가중치 처리**와 **음수 사이클 탐지**라는 강력한 기능 덕분에 다양한 상황에서 활용될 수 있다. 네트워크 라우팅 프로토콜(RIP) 등 실제 세계의 문제 해결에도 사용되는 중요한 알고리즘이었다.
