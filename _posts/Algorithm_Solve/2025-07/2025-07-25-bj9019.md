---
layout: post
title:  "[ë°±ì¤€] 9019ë²ˆ: DSLR"
date:   2025-07-25 00:00:00 +0900
categories: Algorithm_Solve
tags: [algorithm, bfs, graph-traversal, simulation]
---

<br>

### ğŸ’» ë°±ì¤€ 9019ë²ˆ: DSLR

- **ë¬¸ì œ ë§í¬:** [https://www.acmicpc.net/problem/9019](https://www.acmicpc.net/problem/9019)
- **ì•Œê³ ë¦¬ì¦˜ ë¶„ë¥˜:** ë„ˆë¹„ ìš°ì„  íƒìƒ‰, ê·¸ë˜í”„ ì´ë¡ , ê·¸ë˜í”„ íƒìƒ‰, ì‹œë®¬ë ˆì´ì…˜


## ë¬¸ì œ ì†Œê°œ ğŸ§

ë„¤ ê°œì˜ ëª…ë ¹ì–´(D, S, L, R)ë¥¼ ì‚¬ìš©í•˜ëŠ” ê³„ì‚°ê¸°ì—ì„œ, ì£¼ì–´ì§„ ìˆ«ì Aë¥¼ ë‹¤ë¥¸ ìˆ«ì Bë¡œ ë°”ê¾¸ëŠ” ìµœì†Œí•œì˜ ëª…ë ¹ì–´ ìˆœì„œë¥¼ ì°¾ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

- **D (Double):** nì„ 2ë°°ë¡œ ë§Œë“¤ê³  10000ìœ¼ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
- **S (Subtract):** nì—ì„œ 1ì„ ëºë‹ˆë‹¤. (0ì¼ ê²½ìš° 9999 ì €ì¥)
- **L (Left Rotate):** nì˜ ë„¤ ìë¦¿ìˆ˜ë¥¼ ì™¼ìª½ìœ¼ë¡œ íšŒì „ì‹œí‚µë‹ˆë‹¤. (1234 -> 2341)
- **R (Right Rotate):** nì˜ ë„¤ ìë¦¿ìˆ˜ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ íšŒì „ì‹œí‚µë‹ˆë‹¤. (1234 -> 4123)


### ì…ë ¥ ğŸ“

- ì²« ì¤„ì— í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ìˆ˜ Tê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
- ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§ˆë‹¤, ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ëœ ë‘ ì •ìˆ˜ Aì™€ Bê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. (0 <= A, B < 10000)


### ì¶œë ¥ ğŸ“¤

- Aë¥¼ Bë¡œ ë°”ê¾¸ëŠ” ê°€ì¥ ì§§ì€ ëª…ë ¹ì–´ ì¡°í•©ì„ ì¶œë ¥í•©ë‹ˆë‹¤.


### ì œí•œ âŒ

- **ì‹œê°„:** 6ì´ˆ
- **ë©”ëª¨ë¦¬:** 256MB


### ì²« ë²ˆì§¸ ì‹œë„: BFSì™€ ë¬¸ìì—´ ì—°ì‚° ğŸ‘Š

#### Idea

BFSë¥¼ ì‚¬ìš©í•˜ì—¬ ê°€ëŠ¥í•œ ëª¨ë“  ëª…ë ¹ì–´ ì¡°í•©ì„ íƒìƒ‰í•œë‹¤. ê° ìˆ«ìëŠ” ë…¸ë“œ, ëª…ë ¹ì–´ëŠ” ê°„ì„ ìœ¼ë¡œ ìƒê°í•  ìˆ˜ ìˆë‹¤. Lê³¼ R ì—°ì‚°ì€ íŒŒì´ì¬ì˜ ë¬¸ìì—´ ìŠ¬ë¼ì´ì‹±ì„ í™œìš©í•˜ì—¬ êµ¬í˜„í•˜ê³ , ë°©ë¬¸í•œ ìˆ«ìë¥¼ ê¸°ë¡í•˜ì—¬ ì¤‘ë³µ íƒìƒ‰ì„ í”¼í•œë‹¤.

#### Code

```python
import sys
from collections import deque

def op_D(n:int):
    n *= 2
    if n > 9999:
        return n % 10000
    return n

def op_S(n:int):
    if n == 0:
        return 9999
    return n - 1

def op_L(n:int):
    n_str = str(n).rjust(4, '0')
    new_n_str = n_str[1:] + n_str[0]
    return int(new_n_str)

def op_R(n:int):
    n_str = str(n).rjust(4, '0')
    new_n_str = n_str[-1] + n_str[:-1]
    return int(new_n_str)

def solve():
    A, B = map(int, sys.stdin.readline().split())
    queue = deque([(A, "")])
    visited = {A}

    while queue:
        cur_num, path = queue.popleft()

        if cur_num == B:
            print(path)
            return

        # D
        next_d = op_D(cur_num)
        if next_d not in visited:
            visited.add(next_d)
            queue.append((next_d, path + 'D'))

        # S
        next_s = op_S(cur_num)
        if next_s not in visited:
            visited.add(next_s)
            queue.append((next_s, path + 'S'))

        # L
        next_l = op_L(cur_num)
        if next_l not in visited:
            visited.add(next_l)
            queue.append((next_l, path + 'L'))

        # R
        next_r = op_R(cur_num)
        if next_r not in visited:
            visited.add(next_r)
            queue.append((next_r, path + 'R'))

t = int(sys.stdin.readline().rstrip())
for _ in range(t):
    solve()
```


#### Result

- **ì‹œê°„ ì´ˆê³¼:** ë¬¸ìì—´ ë³€í™˜ ë° ì²˜ë¦¬ ê³¼ì •ì—ì„œ ë°œìƒí•˜ëŠ” ì˜¤ë²„í—¤ë“œê°€ ì»¤ì„œ ì‹œê°„ ì œí•œì„ ì´ˆê³¼í•˜ëŠ” ê²ƒ ê°™ë‹¤. íŠ¹íˆ L, R ì—°ì‚°ê³¼ `visited` ì…‹ì—ì„œì˜ í™•ì¸ ê³¼ì •ì´ ì‹œê°„ì´ ê½¤ ê±¸ë¦¬ëŠ” ê²ƒ ê°™ì•˜ë‹¤.


### ë‘ ë²ˆì§¸ ì‹œë„: BFS ìµœì í™” (ì‚°ìˆ  ì—°ì‚° ë° ê²½ë¡œ ì—­ì¶”ì ) âœ¨

#### Idea

ë¬¸ìì—´ ì—°ì‚°ì„ ì‚°ìˆ  ì—°ì‚°ìœ¼ë¡œ ëŒ€ì²´í•˜ì—¬ L, R ëª…ë ¹ì–´ì˜ ì„±ëŠ¥ì„ ê°œì„ í•œë‹¤. ë˜í•œ, ë§¤ë²ˆ íì— ê²½ë¡œ ë¬¸ìì—´ ì „ì²´ë¥¼ ì €ì¥í•˜ëŠ” ëŒ€ì‹ , `parent` ë°°ì—´ì„ ë§Œë“¤ì–´ ì–´ë–¤ ìˆ«ìë¡œë¶€í„° í˜„ì¬ ìˆ«ìê°€ ë§Œë“¤ì–´ì¡ŒëŠ”ì§€, ê·¸ë¦¬ê³  ì–´ë–¤ ì—°ì‚°ì´ ì‚¬ìš©ë˜ì—ˆëŠ”ì§€ë¥¼ ê¸°ë¡í•´ì„œ. ëª©í‘œ ìˆ«ìì— ë„ë‹¬í•˜ë©´, `parent` ë°°ì—´ì„ **ì—­ì¶”ì **í•˜ì—¬ ìµœì¢… ê²½ë¡œë¥¼ êµ¬ì„±í•œë‹¤.

#### Code

```python
import sys
from collections import deque

def solve():
    A, B = map(int, sys.stdin.readline().split())
    queue = deque([A])
    # visited[i] = (ì´ì „ ìˆ«ì, ì‚¬ìš©ëœ ëª…ë ¹ì–´)
    visited = {A: (None, None)} 

    while queue:
        cur_num = queue.popleft()

        if cur_num == B:
            path = ''
            # ì—­ì¶”ì í•˜ì—¬ ê²½ë¡œ ìƒì„±
            while cur_num != A:
                prev_num, op = visited[cur_num]
                path = op + path
                cur_num = prev_num
            print(path)
            return

        # D
        next_d = (cur_num * 2) % 10000
        if next_d not in visited:
            visited[next_d] = (cur_num, 'D')
            queue.append(next_d)

        # S
        next_s = (cur_num - 1) if cur_num != 0 else 9999
        if next_s not in visited:
            visited[next_s] = (cur_num, 'S')
            queue.append(next_s)

        # L
        next_l = (cur_num % 1000) * 10 + (cur_num // 1000)
        if next_l not in visited:
            visited[next_l] = (cur_num, 'L')
            queue.append(next_l)

        # R
        next_r = (cur_num % 10) * 1000 + (cur_num // 10)
        if next_r not in visited:
            visited[next_r] = (cur_num, 'R')
            queue.append(next_r)

t = int(sys.stdin.readline().rstrip())
for _ in range(t):
    solve()

```


#### Result

- **ì‹œê°„ ì´ˆê³¼ (Python 3), ì •ë‹µ (PyPy3):** ì²« ë²ˆì§¸ ì‹œë„ë³´ë‹¤ í›¨ì”¬ ë¹¨ë¼ì¡Œì§€ë§Œ, Python 3ì—ì„œëŠ” ì—¬ì „íˆ ì‹œê°„ ì œí•œì„ í†µê³¼í•˜ì§€ ëª»í–ˆë‹¤. PyPyì˜ JIT ì»´íŒŒì¼ëŸ¬ê°€ ë°˜ë³µì ì¸ ì—°ì‚°ì„ ë” íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ê¸° ë•Œë¬¸ì— PyPyì—ì„  í†µê³¼í•  ìˆ˜ ìˆì—ˆë‹¤.


## ê°œì„ í•  ë¶€ë¶„ ğŸ¤”

- **Python 3 í†µê³¼ë¥¼ ìœ„í•œ ìµœì í™”:** Python 3ë¡œ í†µê³¼í•˜ê¸° ìœ„í•´ì„œëŠ” ë” ì í•©í•œ ì•Œê³ ë¦¬ì¦˜ì„ ì°¾ì•„ ì ìš©í•´ì•¼ê² ë‹¤. í˜„ì¬ ì½”ë“œì—ì„œ Pythonì˜ ì„±ëŠ¥ í•œê³„ë¥¼ ëŠê¼ˆë‹¤.
- **ì½”ë“œ ê°€ë…ì„±:** ê° ì—°ì‚°ì„ ë³„ë„ì˜ í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•˜ë©´ ê°€ë…ì„±ì„ ë” ë†’ì¼ ìˆ˜ ìˆì§€ë§Œ, BFS ë£¨í”„ ë‚´ì— ì§ì ‘ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ì•½ê°„ì˜ ì„±ëŠ¥ ì´ì ì„ ê°€ì§ˆ ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.

<div style="text-align: center">â‚</div>
