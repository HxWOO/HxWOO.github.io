---
layout: post
title:  "ë°±ì¤€ 1991ë²ˆ: íŠ¸ë¦¬ ìˆœíšŒ ë¬¸ì œ í’€ì´ ê³¼ì •"
date:   2025-08-11 10:00:00 +0900
categories: Algorithms
tags: [algorithm, tree, traversal, recursion]
---

<br>

### ğŸ’» ë°±ì¤€ 1991ë²ˆ: íŠ¸ë¦¬ ìˆœíšŒ

- **ë¬¸ì œ ë§í¬:** [https://www.acmicpc.net/problem/1991](https://www.acmicpc.net/problem/1991)
- **ì•Œê³ ë¦¬ì¦˜ ë¶„ë¥˜:** íŠ¸ë¦¬, ì¬ê·€

---

## ë¬¸ì œ ì†Œê°œ ğŸ§

ì´ì§„ íŠ¸ë¦¬ë¥¼ ì…ë ¥ë°›ì•„ ì „ìœ„ ìˆœíšŒ(preorder traversal), ì¤‘ìœ„ ìˆœíšŒ(inorder traversal), í›„ìœ„ ìˆœíšŒ(postorder traversal)í•œ ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ëŠ” ë¬¸ì œì˜€ë‹¤.

### ì…ë ¥ ğŸ“
> ì²«ì§¸ ì¤„ì— ì´ì§„ íŠ¸ë¦¬ì˜ ë…¸ë“œ ê°œìˆ˜ N(1 â‰¤ N â‰¤ 26)ì´ ì£¼ì–´ì§„ë‹¤.  
> ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì— ê±¸ì³ ê° ë…¸ë“œì™€ ê·¸ì˜ ì™¼ìª½ ìì‹ ë…¸ë“œ, ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œê°€ ì£¼ì–´ì§„ë‹¤.  
> ë…¸ë“œì˜ ì´ë¦„ì€ Aë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ì•ŒíŒŒë²³ ëŒ€ë¬¸ìë¡œ ë§¤ê²¨ì§€ë©°, í•­ìƒ Aê°€ ë£¨íŠ¸ ë…¸ë“œê°€ ëœë‹¤. ìì‹ ë…¸ë“œê°€ ì—†ëŠ” ê²½ìš°ì—ëŠ” .ìœ¼ë¡œ í‘œí˜„í•œë‹¤.

### ì¶œë ¥ ğŸ“¤
> ì´ 3ì¤„ì— ê±¸ì³ ì „ìœ„ ìˆœíšŒ, ì¤‘ìœ„ ìˆœíšŒ, í›„ìœ„ ìˆœíšŒí•œ ê²°ê³¼ë¥¼ ê°ê° ì¶œë ¥í•œë‹¤. ê° ì¤„ì— Nê°œì˜ ì•ŒíŒŒë²³ì„ ê³µë°± ì—†ì´ ì¶œë ¥í•˜ë©´ ëœë‹¤.

### ì œí•œ âŒ

- **ì‹œê°„:** 2ì´ˆ
- **ë©”ëª¨ë¦¬:** 128 MB

---

### ë‚˜ì˜ í’€ì´: ë°˜ë³µë¬¸ê³¼ íë¥¼ ì´ìš©í•œ ì‹œë„ ğŸ˜¥

#### Idea

ì²˜ìŒì—” `Node` í´ë˜ìŠ¤ë¥¼ ì§ì ‘ ì •ì˜í•˜ê³ , ê° ë…¸ë“œë¥¼ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•œ ë’¤ ë°˜ë³µë¬¸ê³¼ í(`deque`)ë¥¼ ì‚¬ìš©í•´ ìˆœíšŒë¥¼ êµ¬í˜„í•˜ë ¤ í–ˆë‹¤. ì „ìœ„ ìˆœíšŒëŠ” ìŠ¤íƒì²˜ëŸ¼, ë‚˜ë¨¸ì§€ëŠ” íì²˜ëŸ¼ ë™ì‘í•˜ê²Œ í•˜ë ¤ë‹¤ ë³´ë‹ˆ ë¡œì§ì´ ë§¤ìš° ë³µì¡í•´ì¡Œë‹¤.

#### Code

```python
import sys
from collections import deque

class Node:
    val: int
    left: "Node"
    right: "Node"
    parent: "Node"
    visited: bool

    def __init__(self, val: str):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None
        self.visited = False

    def set_child(self, left, right):
        self.left = left
        self.right = right
    
    def set_parent(self, parent):
        self.parent = parent

    def __str__(self):
        return self.val

    def get_right(self):
        return self.right
    def get_left(self):
        return self.left
    def get_parent(self):
        return self.parent

n = int(sys.stdin.readline().rstrip())
node_list = list()
in_list = [list(map(lambda x: ord(x)-65, sys.stdin.readline().split())) for _ in range(n)]

for i in range(65, 91):
    node = Node(chr(i))
    node_list.append(node)

def reset_node_tree(in_list):
    global node_list
    for li in in_list:  # '.' ì€ 46ë²ˆ
        node_idx, l_idx, r_idx = li
        node: Node = node_list[node_idx]
        left = node_list[l_idx] if 0 <= l_idx else None
        right = node_list[r_idx] if 0 <= r_idx else None
        node.set_child(left, right)
        left.set_parent(node) if left != None else None
        right.set_parent(node) if right != None else None
    for node in node_list:
        node.visited = False

# ì „ìœ„ ìˆœíšŒ v l r
def prev_search():
    global node_list
    q = deque()
    q.append(node_list[0])
    answer = ""
    while q:
        node = q.pop()
        answer += node.__str__()
        if node.get_right() is not None:
            q.append(node.get_right())
        if node.left is not None:
            q.append(node.get_left())
    print(answer)

def mid_search(): # ì¤‘ìœ„ ìˆœíšŒ, l v r
    global node_list
    q = deque()
    q.append(node_list[0])
    answer = ""
    while q:
        node = q.popleft()
        if node.left != None:
            q.appendleft(node.get_left())
        elif not node.visited:
            answer += node.__str__()
            parent = node.get_parent()
            node.visited = True
            if parent != None:
                parent.set_child(None, None)
                q.appendleft(parent)

        if node.right != None:
            q.append(node.get_right())
            
    print(answer)

def end_search(): # í›„ìœ„ ìˆœíšŒ, l r v
    global node_list
    q = deque()
    q.append(node_list[0])
    answer = ""
    while q:
        node = q.popleft()
        # ìì‹ ë…¸ë“œ ë‹´ê¸°
        if node.left != None:
            q.append(node.get_left())
        if node.right != None:
            q.append(node.get_right())
        
        if node.left is None and node.right is None and not node.visited:  # ë§ë‹¨ ë…¸ë“œë©´
            parent = node.get_parent()
            if parent is None:
                continue
            if node == parent.left: # parentì™€ì˜ ì—°ê²°ì„ ëŠìŒ
                parent.set_child(None, parent.right)
            else:
                parent.set_child(parent.left, None)
            q.appendleft(parent)
            node.visited = True
            answer += node.__str__()
            
    print(answer + 'A')

reset_node_tree(in_list)
prev_search()
mid_search()
reset_node_tree(in_list)
end_search()
```

#### Result

**ì‹¤íŒ¨!** ğŸ˜±

ì¤‘ìœ„, í›„ìœ„ ìˆœíšŒë¥¼ ë°˜ë³µë¬¸ìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ë¡œì§ì´ ë„ˆë¬´ ë³µì¡í–ˆë‹¤. íŠ¹íˆ ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ì²˜ë¦¬í•˜ê³  ë¶€ëª¨ ë…¸ë“œë¡œ ëŒì•„ê°€ëŠ” ê³¼ì •ì—ì„œ ì˜ˆì™¸ ì¼€ì´ìŠ¤ê°€ ë§ì•„ ê²°êµ­ í•´ê²°í•˜ì§€ ëª»í–ˆë‹¤.

---

### ë‘ ë²ˆì§¸ ì‹œë„: ì¬ê·€ë¥¼ í™œìš©í•œ í’€ì´ ğŸ‰

#### Idea âœ¨

ë³µì¡í•œ ë°˜ë³µë¬¸ ëŒ€ì‹  **ì¬ê·€(Recursion)** ë¥¼ ì‚¬ìš©í•˜ë©´ í›¨ì”¬ ê°„ê²°í•˜ê²Œ íŠ¸ë¦¬ ìˆœíšŒë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ê¹¨ë‹¬ì•˜ë‹¤.
- **ì „ìœ„ ìˆœíšŒ:** `(ë£¨íŠ¸) -> (ì™¼ìª½) -> (ì˜¤ë¥¸ìª½)` ìˆœì„œë¡œ ì¬ê·€ í˜¸ì¶œ
- **ì¤‘ìœ„ ìˆœíšŒ:** `(ì™¼ìª½) -> (ë£¨íŠ¸) -> (ì˜¤ë¥¸ìª½)` ìˆœì„œë¡œ ì¬ê·€ í˜¸ì¶œ
- **í›„ìœ„ ìˆœíšŒ:** `(ì™¼ìª½) -> (ì˜¤ë¥¸ìª½) -> (ë£¨íŠ¸)` ìˆœì„œë¡œ ì¬ê·€ í˜¸ì¶œ

ë˜í•œ, ë…¸ë“œë¥¼ ë¦¬ìŠ¤íŠ¸ê°€ ì•„ë‹Œ **ë”•ì…”ë„ˆë¦¬**ë¡œ ê´€ë¦¬í•˜ë©´ `{'A': Node('A'), ...}` ì™€ ê°™ì´ ê° ë…¸ë“œì— ì´ë¦„ìœ¼ë¡œ ë°”ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆì–´ í¸ë¦¬í•˜ê² ë‹¤ê³  ìƒê°í–ˆë‹¤.

#### Code

```python
import sys

class Node:
    def __init__(self, val: str):
        self.val = val
        self.left = None
        self.right = None

def preorder(node):
    if node is None:
        return ""
    return node.val + preorder(node.left) + preorder(node.right)

def inorder(node):
    if node is None:
        return ""
    return inorder(node.left) + node.val + inorder(node.right)

def postorder(node):
    if node is None:
        return ""
    return postorder(node.left) + postorder(node.right) + node.val

n = int(sys.stdin.readline().rstrip())
nodes = {chr(65 + i): Node(chr(65 + i)) for i in range(26)}  # A~Z ë¯¸ë¦¬ ìƒì„±

for _ in range(n):
    p, l, r = sys.stdin.readline().split()
    if l != '.':
        nodes[p].left = nodes[l]
    if r != '.':
        nodes[p].right = nodes[r]

root = nodes['A']  # í•­ìƒ Aê°€ ë£¨íŠ¸ë¼ê³  ê°€ì •

print(preorder(root))
print(inorder(root))
print(postorder(root))
```

#### Result

**ì„±ê³µ!** âœ…

ì¬ê·€ë¥¼ ì‚¬ìš©í•˜ë‹ˆ ì½”ë“œê°€ ë†€ëë„ë¡ ê°„ê²°í•´ì§€ê³ , ê° ìˆœíšŒì˜ ë…¼ë¦¬ê°€ ëª…í™•í•˜ê²Œ ë“œëŸ¬ë‚¬ë‹¤. ë”•ì…”ë„ˆë¦¬ë¡œ ë…¸ë“œë¥¼ ê´€ë¦¬í•˜ë‹ˆ íŠ¹ì • ë…¸ë“œë¥¼ ì°¾ì•„ ì—°ê²°í•˜ëŠ” ê³¼ì •ë„ í›¨ì”¬ ì‰¬ì›Œì¡Œë‹¤.

---

## ë°°ìš´ ì  ë° ëŠë‚€ ì  âœï¸

- **ì¬ê·€ì˜ í˜:** íŠ¸ë¦¬, ê·¸ë˜í”„ì™€ ê°™ì´ ì¬ê·€ì ì¸ ìë£Œêµ¬ì¡°ëŠ” ë°˜ë³µë¬¸ë³´ë‹¤ ì¬ê·€ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ í›¨ì”¬ ì§ê´€ì ì´ê³  íš¨ìœ¨ì ì¼ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ê¹¨ë‹¬ì•˜ë‹¤.
- **ìë£Œêµ¬ì¡° ì„ íƒì˜ ì¤‘ìš”ì„±:** ë¬¸ì œì˜ íŠ¹ì„±ì— ë§ëŠ” ì ì ˆí•œ ìë£Œêµ¬ì¡°(ì´ë²ˆì—” ë”•ì…”ë„ˆë¦¬)ë¥¼ ì„ íƒí•˜ëŠ” ê²ƒì´ ì½”ë“œì˜ ê°„ê²°ì„±ê³¼ íš¨ìœ¨ì„±ì„ í¬ê²Œ ì¢Œìš°í•œë‹¤ëŠ” ê²ƒì„ ë°°ì› ë‹¤.
- **ì‹¤íŒ¨ë¡œë¶€í„° ë°°ìš°ê¸°:** ì²« ë²ˆì§¸ ì‹œë„ì˜ ì‹¤íŒ¨ ì›ì¸ì„ ë¶„ì„í•˜ê³  ë‹¤ë¥¸ ì ‘ê·¼ë²•ì„ ê³ ë¯¼í•˜ëŠ” ê³¼ì •ì—ì„œ ë” ë‚˜ì€ í•´ê²°ì±…ì„ ì°¾ì„ ìˆ˜ ìˆì—ˆë‹¤. ë³µì¡í•œ ì½”ë“œëŠ” ë²„ë¦¬ê³  ë” ê°„ë‹¨í•œ í•´ê²°ì±…ì„ ì°¾ëŠ” ìš©ê¸°ë„ í•„ìš”í•˜ë‹¤.
- **ê¸°ë³¸ê¸°:** íŠ¸ë¦¬ ìˆœíšŒì™€ ê°™ì€ ê¸°ë³¸ì ì¸ ê°œë…ì— ëŒ€í•œ í™•ì‹¤í•œ ì´í•´ê°€ ë’·ë°›ì¹¨ë˜ì–´ì•¼ ì‘ìš© ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.